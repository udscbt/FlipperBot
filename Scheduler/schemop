#!/usr/bin/env python
import sys
import re
import argparse
from collections import OrderedDict
from os.path import join, dirname, basename

from random import random

termColors = {
    'PURPLE' : '\033[95m',
    'BLUE' : '\033[94m',
    'GREEN' : '\033[92m',
    'YELLOW' : '\033[93m',
    'RED' : '\033[91m',
    'END' : '\033[0m',
    'BOLD' : '\033[1m',
    'UNDERLINE' : '\033[4m'
 }

def stderr(*args, **kwargs):
  print(*args, file=sys.stderr, **kwargs)

CMD_PREFIX_D  = '@SCHEMO_'
CMD_PREFIX_O  = 'SCHEMO_'
CMD_PREFIX_P  = 'SCHEMO_P_'
CMD_PREFIX_SH = '@'
FILE_PREFIX_D = '__schemo_'
VAR_PREFIX_D  = '__schemo_'

parser = argparse.ArgumentParser(description='Preprocessor for ScheMo based source files', add_help=False)
parser.add_argument('-?', '--help', action='help')
parser.add_argument('-q', '--quiet', dest='quiet', action='store_true',
                    help='Do not print to stdout')
parser.add_argument('-h', '--header', dest='header', action='store_true',
                    help='Print file header to stdout (used with -q)')
parser.add_argument('-s', '--shorthand', dest='shorthand', action='store_true',
                    help='Equivalent to -c@')
parser.add_argument('-c', '--command', dest='cp', metavar='PREFIX',
                    action='store', default=CMD_PREFIX_D, type=str,
                    help='Prefix for ScheMo commands. [Default: '
                    +CMD_PREFIX_D+']')
parser.add_argument('-f', '--file-prefix', dest='fp', metavar='PREFIX',
                    action='store', default=FILE_PREFIX_D, type=str,
                    help='Prefix for output files. [Default: '
                    +FILE_PREFIX_D+']')
parser.add_argument('-V', '--var-prefix', dest='vp', metavar='PREFIX',
                    action='store', default=VAR_PREFIX_D, type=str,
                    help='Prefix for ScheMo autogenerated variables. [Default: '
                    +VAR_PREFIX_D+']')
parser.add_argument('-d', '--directory', dest='dir', metavar='DIRECTORY',
                    action='store', default=None, type=str,
                    help='Directory for output files')
parser.add_argument('--evil', dest='evil', action='store_true',
                    help='Activate evil substitution mode')
parser.add_argument('-p', '--enable-profiler', dest='profiler',
                    action='store_true', help='Enable profiler')
parser.add_argument('files', metavar='FILE', type=str, nargs='+',
                    help='files to be processed')

args = parser.parse_args()

CMD_PREFIX  = CMD_PREFIX_SH if args.shorthand else args.cp
FILE_PREFIX = args.fp
VAR_PREFIX  = args.vp

OUT_DIR     = args.dir

def CMD(name):
  return CMD_PREFIX+name
  
def CMD_O(name):
  return CMD_PREFIX_O+name

if args.profiler:
  from schemop_profiler import *

def CMD_P(name):
  return CMD_PREFIX_P+name

FILE_HEADER = """/*************************************
 * Auto-generated ScheMo source file *
 *************************************
 * Original file name: {name}
 * New file name: {newname}
 * Identified jobs: {jobn}
 *   Named: {njobn}
 *   Unnamed: {ujobn}
 * Identified tasks: {taskn}
 *   Named: {ntaskn}
 *   Unnamed: {utaskn}
 */

"""

DEC       = CMD('DECLARE')
DEC_O     = CMD_O('DECLARE')
INIT      = CMD('INIT')
INIT_O    = CMD_O('INIT')
JOB       = CMD('JOB')
JOB_O     = CMD_O('JOB')
DECJOB    = CMD('DECLARE_JOB')
DECJOB_O  = CMD_O('DECLARE_JOB')
INTJOB    = CMD('INIT_JOB')
INTJOB_O  = CMD_O('INIT_JOB')
TBREAK    = CMD('TBREAK')
TBREAK_O  = CMD_O('TBREAK')
DECTSK    = CMD('DECLARE_TASK')
DECTSK_O  = CMD_O('DECLARE_TASK')
SCHALL    = CMD('SCHEDULE_ALL')
SCHALL_O  = CMD_O('SCHEDULE_ALL')
SCHJOB    = CMD('SCHEDULE_JOB')
SCHJOB_O  = CMD_O('SCHEDULE_JOB')
JMEM      = CMD('MEMORY')
JMEM_O    = CMD_O('JOB_MEMORY')
JVAR      = CMD('VAR')
JVAR_O    = CMD_O('JVAR')
DECJVAR   = CMD('DECLARE_JVAR')
DECJVAR_O = CMD_O('DECLARE_JVAR')
WHILE     = CMD('WHILE')
WHILE_O   = CMD_O('WHILE')
LOOP      = CMD('LOOPBACK')
LOOP_O    = CMD_O('LOOPBACK')
CONT      = CMD('CONTINUE')
CONT_O    = CMD_O('CONTINUE')
BREAK     = CMD('BREAK')
BREAK_O   = CMD_O('BREAK')
IF        = CMD('IF')
IF_O      = CMD_O('IF')
ELSE      = CMD('ELSE')
ELSE_O    = CMD_O('ELSE')
ENDIF     = CMD('ENDIF')
ENDIF_O   = CMD_O('ENDIF')
JDELAY    = CMD('JDELAY')
JDELAY_O  = CMD_O('JDELAY')
FUN       = CMD('FUNCTION')
FUN_O     = CMD_O('FUNCTION')
PAR       = CMD('PARAM')
PAR_O     = CMD_O('PARAM')
RET       = CMD('RETURN')
RET_O     = CMD_O('RETURN')
PARSTK    = CMD('PARAM_STACK')
PARSTK_O  = CMD_O('PARAM_STACK')
DPARSTK   = CMD('DECLARE_PARAM_STACK')
DPARSTK_O = CMD_O('DECLARE_PARAM_STACK')
RETSTK    = CMD('RETURN_STACK')
RETSTK_O  = CMD_O('RETURN_STACK')
DRETSTK   = CMD('DECLARE_RETURN_STACK')
DRETSTK_O = CMD_O('DECLARE_RETURN_STACK')
GBSTK     = CMD('GETBACK_STACK')
GBSTK_O   = CMD_O('GETBACK_STACK')
DGBSTK    = CMD('DECLARE_GETBACK_STACK')
DGBSTK_O  = CMD_O('DECLARE_GETBACK_STACK')
CALL      = CMD('CALL')
CALL_O    = CMD_O('CALL')
GETBACK   = CMD('GETBACK')
GETBACK_O = CMD_O('GETBACK')
PSHPAR    = CMD('PUSH_PARAM')
PSHPAR_O  = CMD_O('PUSH_PARAM')
DELPAR    = CMD('DELETE_PARAM')
DELPAR_O  = CMD_O('DELETE_PARAM')
FVAR      = CMD('FVAR')
FVAR_O    = CMD_O('FVAR')
DECFVAR   = CMD('DECLARE_FVAR')
DECFVAR_O = CMD_O('DECLARE_FVAR')
INTFVAR   = CMD('INIT_FVAR')
INTFVAR_O = CMD_O('INIT_FVAR')
PSHFVAR   = CMD('PUSH_FVAR')
PSHFVAR_O = CMD_O('PUSH_FVAR')
DELFVAR   = CMD('DELETE_FVAR')
DELFVAR_O = CMD_O('DELETE_FVAR')
MUTEXS    = CMD('MUTEX_START')
MUTEXS_O  = CMD_O('MUTEX_START')
MUTEXE    = CMD('MUTEX_END')
MUTEXE_O  = CMD_O('MUTEX_END')
CRITSEC   = CMD('CRITSEC')
CRITSEC_O = CMD_O('CRITSEC')
DECMUT    = CMD('DECLARE_MUTEX')
DECMUT_O  = CMD_O('DECLARE_MUTEX')
SETNUM    = CMD('SET_NUM_JOBS')
SETNUM_O  = CMD_O('SET_NUM_JOBS')
EXIT      = CMD('EXIT')
EXIT_O    = CMD_O('EXIT')
SHTDWN    = CMD('SHUTDOWN')
SHTDWN_O  = CMD_O('SHUTDOWN')

#PROFILER
T_SETID   = CMD_P('TASK_SETID')
J_SETID   = CMD_P('JOB_SETID')

IGNORE_PATTERN = "(?:\n\s*#line \d*\n|\s*)*"

COMMENT_1_PATTERN = re.compile("/\*.*?\*/", flags=re.DOTALL)
COMMENT_2_PATTERN = re.compile("//.*?(\n|$)", flags=re.DOTALL)
def clean(buf):
  return COMMENT_2_PATTERN.sub("\n", COMMENT_1_PATTERN.sub("", buf))

JOB_PREFIX = 'job_'
JOB_INDEX  = 0
JOB_PATTERN_UNNAMED = re.compile("("+JOB+"){0}[^(]".format(IGNORE_PATTERN))
JOB_PATTERN_NAMED = re.compile(JOB+"{0}\({0}([^,]+?){0}\)".format(IGNORE_PATTERN))
def JOB_NAME():
  global JOB_INDEX
  name = VAR_PREFIX+JOB_PREFIX+str(JOB_INDEX)
  JOB_INDEX = JOB_INDEX+1
  return name if name not in JOBS else JOB_NAME()
def JOB_FULL(job, task):
  return JOB_O+"("+job+", "+task+")"

JOBS = OrderedDict()
UNNAMED_JOBS = 0

TASK_PREFIX = 'task_'
TASK_INDEX  = 0
TBREAK_PATTERN_UNNAMED = re.compile("("+TBREAK+"){0}[^(]".format(IGNORE_PATTERN))
TBREAK_PATTERN_NAMED = re.compile(TBREAK+"{0}\({0}([^,]+?){0}\)".format(IGNORE_PATTERN))
def TASK_NAME():
  global TASK_INDEX
  name = VAR_PREFIX+TASK_PREFIX+str(TASK_INDEX)
  TASK_INDEX = TASK_INDEX+1
  return name if name not in TASKS else TASK_NAME()
def TBREAK_FULL(task):
  return TBREAK_O+"("+task+")"

TASKS = []
UNNAMED_TASKS = 0

DEC_PATTERN = re.compile(DEC)
INIT_PATTERN = re.compile(INIT)

def replace(string, start, end, replacement):
  return string[:start]+replacement+string[end:]

BLOCK_START_PATTERN = re.compile("{0}{{".format(IGNORE_PATTERN))
def checkBlockStart(buf, open="{"):
  if open == "{":
    pattern = BLOCK_START_PATTERN
  else:
    pattern = re.compile(IGNORE_PATTERN+open)
  return pattern.match(buf) is not None

def getBlock(buf, open="{", close="}"):
  start = buf.find(open)
  lvl = 0
  for i in range(start, len(buf)):
    if buf[i] == open:
      lvl = lvl + 1
    if buf[i] == close:
      lvl = lvl - 1
    if lvl == 0:
      return (start+1, i)
  return None

JVAR_PATTERN = re.compile(JVAR+"{0}\({0}(.+?){0}\){0}".format(IGNORE_PATTERN), flags=re.DOTALL)
JDELAY_PATTERN = re.compile(JDELAY+"{0}\({0}(\d+?){0}\){0}".format(IGNORE_PATTERN))

def parseJob(buf, start, job):
  global UNNAMED_TASKS
  
  subbuf = buf[start:]
  # Code block
  if not checkBlockStart(subbuf):
    stderr("Job '%s' has no attached block of code" % job)
    exit(1)
  ret = getBlock(subbuf)
  if ret is None:
    stderr("Missing '}' in job '%s'" % job)
    sys.exit(1)
  s, e = ret
  block = subbuf[s:e]  
  # Memory block
  while True:
    match = re.search(JMEM, block)
    if match is None:
      break
    if not checkBlockStart(block[match.end():]):
      stderr("Missing memory block in job '%s'" % job)
      stderr("Continuing...")
      continue
    ret = getBlock(block[match.end():])
    if ret is None:
      stderr("Missing '}' in memory block of job '%s'" % job)
      sys.exit(1)
    ss, ee = ret
    ss = ss+match.end()
    ee = ee+match.end()
    memblock = block[ss:ee]
    meminit = ""
    while True:
      m = FVAR_PATTERN.search(memblock)
      if m is None:
        break
      var = m.group(1)
      t = m.group(2)
      if var in JOBS[job]['mem']:
        stderr("Multiple definitions of variable '%s' in memory block of job %s" % (var, job))
        sys.exit(1)
      JOBS[job]['mem'][m.group(1)] = m.group(2)
      memblock = replace(memblock, m.start(), m.end(), "")
    block = replace(block, match.start(), ee+1, "")
  # Delay
  match = JDELAY_PATTERN.search(block)
  
  if match is not None:
    JOBS[job]['delay'] = int(match.group(1))
    block = replace(block, match.start(), match.end(), "")
    
    match = JDELAY_PATTERN.search(block)
    if match is not None:
      stderr("Multiple definitions of %s in job '%s'" % (JDELAY,job))
      stderr("Ignoring all after %d..." % JOBS[job]['delay'])
  block = JDELAY_PATTERN.sub("", block)
  
  blockstart = s
  blockend = e

  block = parseBlock(block)
  
  block = JVAR_PATTERN.sub(JVAR_O + "(\\1, %s)" % job, block)

  return replace(buf, start+blockstart, start+blockend, block)

def parseBlock(block, bw=None, fw=None):
  global UNNAMED_TASKS
  if not block.startswith(CMD_PREFIX):
    i = 0
    while not block[i:].startswith(CMD_PREFIX) and i < len(block):
      i = i+1
    if i >= len(block):
      return block
    else:
      return block[:i]+parseBlock(block[i:], bw=bw, fw=fw)
  
  newindex = 1
  edited = block[:newindex]
  
  #WHILE
  match = re.match(WHILE, block)
  if match is not None:
    if checkBlockStart(block[match.end():], "\("):
      ret = getBlock(block[match.end():], "(", ")")
      if ret is None:
        stderr("Missing ) in %s statement" % WHILE)
        sys.exit(1)
      s, e = ret
      s = match.end()+s
      e = match.end()+e
      condition = "("+block[s:e]+")"
      e = e+1
    else:
      condition = "(true)"
      stderr("Missing condition in %s statement" % WHILE)
      stderr("Assuming '%s'" % condition)
      stderr("Continuing...")
      s = match.start()
      e = match.end()
    if not checkBlockStart(block[e:]):
      stderr("%s statement without attached block of code exists" % WHILE)
      sys.exit(1)
    ret = getBlock(block[e:])
    if ret is None:
      stderr("Missing } in %s statement" % WHILE)
      sys.exit(1)
    task_bk = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(task_bk)
    task_fw = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(task_fw)
    ss, ee = ret
    ss = ss+e
    ee = ee+e
    
    newindex = ee+1
    edited = block[:newindex]
    if args.profiler:
      wnode = profileWhileInside(task_bk, loop=(condition=="(true)"))
    edited = replace(edited, ee, ee+1, LOOP_O+"(%s, %s)" % (task_bk, task_fw))
    edited = replace(edited, ss, ee, parseBlock(edited[ss:ee], bw=task_bk, fw=task_fw))
    edited = replace(edited, match.start(), ss, WHILE_O+"(%s, %s, %s)" % (task_bk, task_fw, condition))
    if args.profiler:
      profileWhileNext(wnode, task_fw)
  
  # CONTINUE
  match = re.match(CONT, block)
  if match is not None:
    if bw is None or fw is None:
      stderr("%s statement must only be used inside %s statements" % (CONT, WHILE))
      sys.exit(1)
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileContinue(bw)
    edited = replace(edited, match.start(), match.end(), CONT_O+"(%s)" % bw)
  
  # BREAK
  match = re.match(BREAK, block)
  if match is not None:
    if bw is None or fw is None:
      stderr("%s statement must only be used inside %s statements" % (BREAK, WHILE))
      sys.exit(1)
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileBreak(bw)
    edited = replace(edited, match.start(), match.end(), BREAK_O+"(%s)" % fw)
  
  # IF
  match = re.match(IF, block)
  if match is not None:
    if checkBlockStart(block[match.end():], "\("):
      ret = getBlock(block[match.end():], "(", ")")
      if ret is None:
        stderr("Missing ) in IF statement")
        sys.exit(1)
      s, e = ret
      s = match.end()+s
      e = match.end()+e
      condition = "("+block[s:e]+")"
      e = e+1
    else:
      condition = "(true)"
      stderr("Missing condition in %s statement" % IF)
      stderr("Assuming '%s'" % condition)
      stderr("Continuing...")
      s = match.start()
      e = match.end()
    if not checkBlockStart(block[e:]):
      stderr("%s statement without attached block of code exists" % IF)
      sys.exit(1)
    ret = getBlock(block[e:])
    if ret is None:
      stderr("Missing } in %s statement" % IF)
      sys.exit(1)
    task_after = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(task_after)
    task_else = task_after
    task_if = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(task_if)
    ss, ee = ret
    ss = ss+e
    ee = ee+e
    ee2 = ee
    
    newindex = ee+1
    edited = block[:newindex]
    
    if args.profiler:
      inode = profileIfInside(task_if)
    inside = parseBlock(block[ss:ee], bw=bw, fw=fw)
    
    #ELSE
    blnElse = False
    match2 = re.match(IGNORE_PATTERN+ELSE, block[newindex:])
    if match2 is not None:
      blnElse = True
      e = match2.end()+newindex
      if not checkBlockStart(block[e:]):
        stderr("%s statement without attached block of code exists" % ELSE)
        sys.exit(1)
      ret = getBlock(block[e:])
      if ret is None:
        stderr("Missing } in %s statement" % ELSE)
        sys.exit(1)
      task_else = TASK_NAME()
      UNNAMED_TASKS = UNNAMED_TASKS + 1
      TASKS.append(task_else)
      ss2, ee2 = ret
      ss2 = ss2+e
      ee2 = ee2+e
      
      newindex = ee2 + 1
      edited = block[:newindex]
      
      if args.profiler:
        inode = profileIfOutside(inode, task_else)
      outside = parseBlock(block[ss2:ee2], bw=bw, fw=fw)
    
    if args.profiler:
      profileIfNext(inode, task_after)
    
    edited = replace(edited, ee2, ee2+1, ENDIF_O+"(%s)" % (task_after))
    if blnElse:
      edited = replace(edited, ss2, ee2, outside)
      edited = replace(edited, ee, ss2, ELSE_O+"(%s, %s)" % (task_else, task_after))
    edited = replace(edited, ss, ee, inside)
    edited = replace(edited, match.start(), ss, IF_O+"(%s, %s, %s)" % (task_if, task_else, condition))
    
  
  # TBREAK
  match = TBREAK_PATTERN_NAMED.match(block)
  if match is not None:
    task  = match.group(1).replace(" ", "")
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileTbreak(task)
    edited = replace(edited, match.start(), match.end(), TBREAK_FULL(task))

  # FUNCTION CALL
  match = CALL_PATTERN.match(block)
  if match is not None:
    ret = match.group(3)
    params = match.group(1).split(";")
    fun = params[0]
    if fun not in FUNCTIONS.keys():
      stderr("Called function '%s' is undefined" % fun)
      sys.exit(1)
    params = params[1:]
    rightn = len(FUNCTIONS[fun]['params'])
    gotn   = len(params)
    if gotn != rightn:
      stderr("Wrong number of parameters for function '%s'" % fun)
      stderr("Expected %d, got %d" % (rightn, gotn))
      sys.exit(1)
    newtask = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(newtask)
    fcall = pushParams(fun, params)
    fcall = fcall + CALL_O + "(%s, %s, %s, %s)\n" % (FUNCTIONS[fun]['return'], fun, newtask, ret)
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileCall(fun, newtask)
    edited = replace(edited, match.start(), match.end(), fcall)
  
  # EXIT
  match = re.match(EXIT, block)
  if match is not None:
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileExit()
    edited = replace(edited, match.start(), match.end(), EXIT_O)
  
  # SHUTDOWN
  match = re.match(SHTDWN, block)
  if match is not None:
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileShutdown()
    edited = replace(edited, match.start(), match.end(), SHTDWN_O)
  
  # RETURN
  match = re.match(RET, block)
  if match is not None:
    
    newindex = match.end()
    edited = block[:newindex]
    if args.profiler:
      profileReturn()
    edited = replace(edited, match.start(), match.end(), "")
  
  # CRITICAL SECTIONS
  match = CRITSEC_PATTERN.match(block)
  if match is not None:
    mutex = match.group(1)
    task = TASK_NAME()
    if not checkBlockStart(block[match.end():]):
      stderr("Void critical section exists")
      stderr("Ignoring...")
      block = replace(block, match.start(), match.end(), "")
      return block
    if mutex not in MUTEXES:
      MUTEXES.append(mutex)
    TASKS.append(task)
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    ret = getBlock(block[match.end():])
    if ret is None:
      stderr("Missing '}' in critical section")
      sys.exit(1)
    s, e = ret
    s = s+match.end()
    e = e+match.end()
    
    newindex = e+1
    edited = block[:newindex]
    edited = replace(edited, e, e+1, MUTEXE_O+"(%s, %s)" % (mutex, task))
    if args.profiler:
      profileCritStart(mutex, task)
    edited = replace(edited, s, e, parseBlock(edited[s:e], bw=bw, fw=fw))
    if args.profiler:
      profileCritEnd(mutex)
    edited = replace(edited, match.start(), s, MUTEXS_O+"(%s, %s)" % (mutex, task))
  
  return edited+parseBlock(block[newindex:], bw=bw, fw=fw)

FUNCTION_PATTERN = re.compile(FUN+"{0}\({0}(.+?){0}\)".format(IGNORE_PATTERN))
PARAM_PATTERN    = re.compile("[^{]*?("+PAR+"{0}\({0}(.+?){0}:{0}(.+?){0}\))".format(IGNORE_PATTERN))
PARAM_PATTERN2   = re.compile(PAR+"{0}\({0}(.+?){0}\)".format(IGNORE_PATTERN))
RETURN_PATTERN   = re.compile("[^{]*?("+RET+"{0}\({0}(.+?){0}\))".format(IGNORE_PATTERN))
RETURN_PATTERN2  = re.compile(RET+"{0}\({0}(.+?){0}\){0};".format(IGNORE_PATTERN))
CALL_PATTERN     = re.compile(CALL+"{0}\({0}(.+?(;.+?)*?){0}\){0}:{0}(.+?){0};".format(IGNORE_PATTERN))
FVAR_PATTERN     = re.compile(JVAR+"{0}\({0}(.+?){0}:{0}(.+?){0}\)".format(IGNORE_PATTERN))

FUNCTIONS = {}

def pushParams(fun, params):
  fparams = ""
  for par, val in zip(FUNCTIONS[fun]['params'], params):
    fparams = fparams + PSHPAR_O + "(%s, %s, %s)\n" % (par, fun, val)
  return fparams

def popParams(fun):
  fparams = ""
  for param, t in FUNCTIONS[fun]['params'].items():
    fparams = fparams + DELPAR_O + "(%s, %s)\n" % (param, fun)
  return fparams

def popVars(fun):
  fvars = ""
  for var, t in FUNCTIONS[fun]['mem'].items():
    fvars = fvars + DELFVAR_O + "(%s, %s)\n" % (var, fun)
  return fvars

def popAll(fun):
  return popParams(fun)+popVars(fun)

def parseFunction(buf, start, fun):
  global UNNAMED_TASKS
  
  FUNCTIONS[fun] = {'params': OrderedDict({}), 'mem': {}}
  subbuf = buf[start:]
  while True:
    match = PARAM_PATTERN.match(subbuf)
    if match is None:
      break
    param = match.group(2)
    t = match.group(3)
    if param in FUNCTIONS[fun]['params']:
      stderr("Multiple definitions of parameter '%s' in function '%s'" % (param,fun))
      stderr("Ignoring all after %s..." % FUNCTIONS[fun]['params'][param])
    else:
      FUNCTIONS[fun]['params'][param] = t
    subbuf = replace(subbuf, match.regs[1][0], match.regs[1][1], "")
  match = RETURN_PATTERN.match(subbuf)
  if match is None:
    #FUNCTIONS[fun]['return'] = 'void'
    stderr("Undefined return type for function '%s'" % fun)
    sys.exit(1)
  else:
    FUNCTIONS[fun]['return'] = match.group(2)
    subbuf = replace(subbuf, match.regs[1][0], match.regs[1][1], "")
  if RETURN_PATTERN.match(subbuf) is not None:
    stderr("Multiple definitions of return value in function '%s'" % fun)
    stderr("Ignoring all after %s..." % FUNCTIONS[fun]['return'])
    RETURN_PATTERN.sub("", subbuf)
  if not checkBlockStart(subbuf):
    stderr("Function '%s' has no attached block of code" % fun)
    exit(1)
  ret = getBlock(subbuf)
  if ret is None:
    stderr("Missing '}' in function '%s'" % fun)
    sys.exit(1)
  s, e = ret
  block = subbuf[s:e]
  
  # Memory block
  while True:
    match = re.search(JMEM, block)
    if match is None:
      break
    if not checkBlockStart(block[match.end():]):
      stderr("Missing memory block in function '%s'" % fun)
      stderr("Continuing...")
      continue
    ret = getBlock(block[match.end():])
    if ret is None:
      stderr("Missing '}' in memory block of fun '%s'" % fun)
      sys.exit(1)
    ss, ee = ret
    ss = ss+match.end()
    ee = ee+match.end()
    memblock = block[ss:ee]
    meminit = ""
    while True:
      m = FVAR_PATTERN.search(memblock)
      if m is None:
        break
      var = m.group(1)
      t = m.group(2)
      if var in FUNCTIONS[fun]['mem']:
        stderr("Multiple definitions of variable '%s' in memory block of function %s" % (var, fun))
        sys.exit(1)
      FUNCTIONS[fun]['mem'][m.group(1)] = m.group(2)
      meminit = ""
      for var, t in FUNCTIONS[fun]['mem'].items():
        meminit = meminit + INTFVAR_O+"(%s, %s, %s)\n" % (var, fun, t)
      memblock = replace(memblock, m.start(), m.end(), meminit)
    block = replace(block, match.start(), ee+1, meminit)
  
  GBstr = GETBACK_O+"(\\1, %s)\n" % fun + popAll(fun) + RET_O
  
  block = RETURN_PATTERN2.sub(RET+GBstr, block)
  
  subbuf = replace(subbuf, s, e, block)
  
  s, e = getBlock(subbuf)
  blockstart = s
  blockend = e
  
  block = subbuf[s:e]

  block = parseBlock(block)
  
  block = JVAR_PATTERN.sub(FVAR_O + "(\\1, %s)" % fun, block)
  block = PARAM_PATTERN2.sub(PAR_O + "(\\1, %s)" % fun, block)
  
  subbuf = replace(subbuf, blockstart, blockend, block)
  
  return replace(buf, start, len(buf), subbuf)

CRITSEC_PATTERN = re.compile(CRITSEC+"{0}\({0}(.+?){0}\)".format(IGNORE_PATTERN))
MUTEXES = []

# PARSING
for path in args.files:
  fin = open(path, "r")
  buf = fin.read()
  fin.close()

  dir = dirname(path)
  name = basename(path)

  # CONSISTENT NAMING FOR INCLUDED FILES
  #~ # INITIALIZE GLOBALS
  #~ TASKS = []
  #~ UNNAMED_TASKS = 0
  #~ JOBS = {}
  #~ UNNAMED_JOBS = 0

  # ADD LINE NUMBERS
  lines = buf.split("\n")
  buf = []
  for i in range(len(lines)):
    if i==0 or not lines[i-1].endswith('\\'):
      buf.append("#line {}".format(i+1))
    buf.append(lines[i])
  buf[0] = buf[0] + ' "{}"'.format(name)
  buf = "\n".join(buf)
  
  
  # REMOVE COMMENTS
  buf = clean(buf)
  
  #EVIL SUBSTITUTION
  if args.evil:
    buf = (
      buf
      .replace("if", IF)
      .replace("while", WHILE)
      .replace("break", BREAK)
      .replace("continue", CONTINUE)
    )
  
  # NAMED TBREAKS
  lastmatch = 0
  while True:
    match = TBREAK_PATTERN_NAMED.search(buf[lastmatch:])
    if match is None:
      break
    task  = match.group(1).replace(" ", "")
    if task in TASKS:
      stderr("Error: multiple uses of task name '%s'" % task)
      sys.exit(1)
    TASKS.append(task)
    lastmatch = match.end()
    #~ buf = replace(buf, match.start(), match.end(), TBREAK_FULL(task))
  
  #FUNCTION NAMES
  lastfun = 0
  while True:
    match = FUNCTION_PATTERN.search(buf[lastfun:])
    if match is None:
      break
    fun = match.group(1).replace(" ", "")
    ms = lastfun + match.start()
    me = lastfun + match.end()
    if fun in TASKS:
      stderr("Error: multiple uses of task name '%s' (note: %ss are tasks)" % (fun, FUN))
      stderr(
        buf[min(0, ms-100):ms]+
        termColors['RED']+
        termColors['BOLD']+
          buf[ms:me]+
        termColors['END']+
        buf[me:max(len(buf), me+100)]
      )
      
      sys.exit(1)
    TASKS.append(fun)
    lastfun = me
  
  # UNNAMED TBREAKS
  lastmatch = 0
  while True:
    match = TBREAK_PATTERN_UNNAMED.search(buf[lastmatch:])
    if match is None:
      break
    task = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    TASKS.append(task)
    #~ buf = replace(buf, match.regs[1][0], match.regs[1][1], TBREAK_FULL(task))
    buf = replace(buf, lastmatch+match.regs[1][0], lastmatch+match.regs[1][1], TBREAK+"("+task+")")
    lastmatch = lastmatch + match.regs[1][1]
  
  # FUNCTION DEFINITIONS
  while True:
    match = FUNCTION_PATTERN.search(buf)
    if match is None:
      break
    fun = match.group(1).replace(" ", "")
    if args.profiler:
      profileFunction(fun)
    buf = parseFunction(buf, match.end(), fun)
    buf = replace(buf, match.start(), match.end(), FUN_O+"(%s)\n" % fun)
  
  # NAMED JOBS
  while True:
    match = JOB_PATTERN_NAMED.search(buf)
    if match is None:
      break
    job  = match.group(1).replace(" ", "")
    if job in JOBS:
      stderr("Error: multiple uses of job name '%s'" % job)
      sys.exit(1)
    task = TASK_NAME()
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    JOBS.update({job:{'task': task, 'mem': {}}})
    TASKS.append(task)
    if args.profiler:
      profileJob(job, task)
    buf = parseJob(buf, match.end(), job)
    buf = replace(buf, match.start(), match.end(), JOB_FULL(job, task))
  
  # UNNAMED JOBS
  while True:
    match = JOB_PATTERN_UNNAMED.search(buf)
    if match is None:
      break
    job  = JOB_NAME()
    task = TASK_NAME()
    UNNAMED_JOBS = UNNAMED_JOBS + 1
    UNNAMED_TASKS = UNNAMED_TASKS + 1
    JOBS.update({job:{'task': task, 'mem': {}}})
    TASKS.append(task)
    if args.profiler:
      profileJob(job, task)
    buf = parseJob(buf, match.regs[1][1], job)
    buf = replace(buf, match.regs[1][0], match.regs[1][1], JOB_FULL(job, task))
  
  # DECLARATIONS
  match = DEC_PATTERN.search(buf)
  if match is not None:
    dec = SETNUM_O + "({})\n".format(len(JOBS))
    for task in TASKS:
      dec = dec + DECTSK_O + "(" + task + ")\n"
    for job, info in JOBS.items():
      dec = dec + DECJOB_O + "(" + job + ")\n"
      for var, t in info['mem'].items():
        dec = dec + DECJVAR_O + "(%s, %s, %s)\n" % (var, job, t)
    for fun, info in FUNCTIONS.items():
      for n, t in info['params'].items():
        dec = dec + DPARSTK_O + "(%s, %s, %s)\n" % (t, n, fun)
      for var, t in info['mem'].items():
        dec = dec + DECFVAR_O + "(%s, %s, %s)\n" % (var, fun, t)
      dec = dec + DRETSTK_O + "(%s, %s)\n" % (info['return'], fun)
      dec = dec + DGBSTK_O + "(%s)\n" % fun
    for mutex in MUTEXES:
      dec = dec + DECMUT_O + "(%s)\n" % mutex
    buf = replace(buf, match.start(), match.end(), dec)
  buf = buf.replace(DEC, DEC_O)

  # INITIALIZATIONS
  match = INIT_PATTERN.search(buf)
  if match is not None:
    init = INIT_O + "\n"
    for job, info in JOBS.items():
      init = init + INTJOB_O + "(" + job + ", " + info['task'] + ")\n"
    if args.profiler:
      for job in JobNode.JOB_NODES:
        init = init + J_SETID + "({}, {})\n".format(
          job.name,
          job.id
        )
      for task in TaskNode.TASK_NODES:
        init = init + T_SETID + "({}, {})\n".format(
          task.name,
          task.id
        )
    buf = replace(buf, match.start(), match.end(), init)
  buf = buf.replace(INIT, "")
  
  # SCHEDULING
  match = re.search(SCHALL, buf)
  if match is not None:
    sch = ""
    for job, info in JOBS.items():
      sch = "%s%s(%s)\n" % (sch, SCHJOB_O,job)
      if 'delay' in info.keys():
        sch = "%s%s(%s,%d)\n" % (sch, JDELAY_O, job, info['delay'])
    buf = replace(buf, match.start(), match.end(), sch) 
  buf = buf.replace(SCHALL, SCHALL_O)

  if OUT_DIR is None:
    OUT_DIR = dir
  newname = FILE_PREFIX+name
  newpath = join(OUT_DIR, newname)
  head_dict = {
    'name': name,
    'newname': newname,
    'jobn': len(JOBS),
    'njobn': len(JOBS)-UNNAMED_JOBS,
    'ujobn': UNNAMED_JOBS,
    'taskn': len(TASKS),
    'ntaskn': len(TASKS)-UNNAMED_TASKS,
    'utaskn': UNNAMED_TASKS,
  }
  header = FILE_HEADER.format(**head_dict)
  buf = header+buf
  if args.quiet:
    if args.header:
      print(header)
  else:
    print(buf)
  
  fout = open(newpath, "w")
  fout.write(buf)
  fout.close()
  
  if args.profiler:
    fout = open(join(OUT_DIR, name+".profile"), "w")
    fout.write("#JOBS NUMBER\n{}\n#JOBS\n#NAME\tID\n".format(len(JobNode.JOB_NODES)))
    for j in JobNode.JOB_NODES:
      fout.write("{}\t{}\n".format(j.name, j.id))
    fout.write("#FUNCTIONS NUMBER\n{}\n#FUNCTIONS\n#NAME\tID\n".format(len(FunctionNode.FUN_NODES)))
    for f in FunctionNode.FUN_NODES:
      fout.write("{}\t{}\n".format(f.name, f.id))
    fout.write("#TASKS NUMBER\n{}\n#TASKS\n#NAME\tID\n".format(len(TaskNode.TASK_NODES)))
    for t in TaskNode.TASK_NODES:
      fout.write("{}\t{}\n".format(t.name, t.id))
    fout.write("#MUTEXES NUMBER\n{}\n#MUTEXES\n#NAME\tID\n".format(len(MutexNode.MUTEX_NODES)))
    for t in MutexNode.MUTEX_NODES:
      fout.write("{}\t{}\n".format(t.name, t.id))
    
    fout.write("#CONTROL FLOWS\n")
    
    fout.write("#JOB\tCONTROL FLOW\n")
    for j in JobNode.JOB_NODES:
      fout.write(str(j)+"\n")
    fout.write("#FUNCTION\tCONTROL FLOW\n")
    for f in FunctionNode.FUN_NODES:
      fout.write(str(f)+"\n")
    fout.close
  
