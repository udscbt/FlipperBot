#!/usr/bin/env python
import sys
import re
import argparse

#PARAMETERS
scale_ = 1
rotation = 0
unaccessible = False
showid = False
showlast = True
showfun = True
showjob = True

parser = argparse.ArgumentParser(description='Converts ScheMo .profile files to LaTeX files', prefix_chars='-+')
parser.add_argument('+u', '--show-unaccessible', dest='unac_true', action='store_true',
                    help='Show unaccessible nodes in output')
parser.add_argument('-u', '--hide-unaccessible', dest='unac_false', action='store_false',
                    help='Hide unaccessible nodes from output')
parser.add_argument('+i', '--show-id', dest='id_true', action='store_true',
                    help='Show tasks ID in output')
parser.add_argument('-i', '--hide-id', dest='id_false', action='store_false',
                    help='Hide tasksID nodes from output')
parser.add_argument('+l', '--show-last', dest='last_true', action='store_true',
                    help='Show last task before end of job/function in output')
parser.add_argument('-l', '--hide-last', dest='last_false', action='store_false',
                    help='Hide last task before end of job/function from output')
parser.add_argument('+f', '--show-functions', dest='fun_true', action='store_true',
                    help='Show functions in output')
parser.add_argument('-f', '--hide-functions', dest='fun_false', action='store_false',
                    help='Hide functions from output')
parser.add_argument('+j', '--show-jobs', dest='job_true', action='store_true',
                    help='Show jobs in output')
parser.add_argument('-j', '--hide-jobs', dest='job_false', action='store_false',
                    help='Hide jobs from output')
parser.add_argument('-s', '--scale', dest='scale', metavar='FACTOR',
                    action='store', default=scale_, type=float,
                    help='Scale factor. [Default: {}]'.format(scale_))
parser.add_argument('-r', '--rotation', dest='rotation', metavar='ANGLE',
                    action='store', default=rotation, type=float,
                    help='Rotation angle. [Default: {}]'.format(rotation))
parser.add_argument('file', metavar='FILE[.profile]', type=str,
                    help='Profile to be processed')

args = parser.parse_args()
scale_ = args.scale
rotation = args.rotation
def mostlyTrue(a, b, c):
  return (a and b) or (b and c) or (a and c)
unaccessible = mostlyTrue(unaccessible, args.unac_true, args.unac_false)
showid = mostlyTrue(showid, args.id_true, args.id_false)
showlast = mostlyTrue(showlast, args.last_true, args.last_false)
showfun = mostlyTrue(showfun, args.fun_true, args.fun_false)
showjob = mostlyTrue(showjob, args.job_true, args.job_false)


scale = scale_*scale_
rot = rotation%180
if rot < 45 or rot > 135:
  vertical = True
else:
  vertical = False

def parseName(name):
  if name.startswith("__schemo_"):
    name = name.replace("__schemo_", "")
    auto = True
  else:
    auto = False
  name = name.replace("_", " ").strip().capitalize()
  if auto:
    name = name + " (auto)"
  name = re.sub(r"\bschemo\b", r"ScheMo", name, flags=re.IGNORECASE)
  return name

class Job:
  all = {}
  
  def __init__(self, name, id):
    self.name = parseName(name)
    self.id = id
    Job.all[self.id] = self
    self.first = None
    self.maxpos = 0
    self.maxlev = 0
    self.position = 0
    self.stop = None

class Function:
  all = {}
  
  def __init__(self, name, id):
    self.name = parseName(name)
    self.id = id
    Function.all[self.id] = self
    self.first = None
    self.maxpos = 0
    self.maxlev = 0
    self.position = 0
    self.stop = None

class Task:
  all = {}
  
  def __init__(self, name=None, id=None):
    if name is not None:
      self.name = parseName(name)
    else:
      self.name = None
    if id is None:
      id = max(Task.all.keys())+1
    self.id = id
    self._in = []
    self._out = []
    self.o_in = []
    self.o_out = []
    Task.all[self.id] = self
    self.level = 0
    self.position = 0
    self.job = None
    self.type = 'task'
    self.order = []
    self.visited = False
  
  def enter(self, task, jump=False):
    if jump:
      self.o_in.append(task)
    else:
      self._in.append(task)
  
  def exit(self, task, jump=False):
    if jump:
      self.o_out.append(task)
    else:
      self._out.append(task)
  
  def setPosition(self, position):
    self.position = position*scale_
    if self.job is not None and self.job.maxpos < position:
      self.job.maxpos = position
  
  def setLevel(self, level):
    self.level = level
    if self.job is not None and self.job.maxlev < level:
      self.job.maxlev = level

def readLine(f):
  line = f.readline()
  while line.startswith("#"):
    line = f.readline()
  return line.replace("\n", "")

def parseFlow(flow, start, level, parent):
  global current
  inner = (flow[start] == '[')
  i = start+1 if inner else start
  last = None
  while True:
    if last is not None:
      current = last
    if flow[i] == 'S':
      if inner:
        raise FormatError()
      else:
        if showlast:
          last.exit(parent.job.stop)
          parent.job.stop.enter(last)
          parent.job.stop.setPosition(parent.job.maxpos+1)
        else:
          s = parent.job.stop
          for t in s._in:
            if t != last:
              last.enter(t)
              t.exit(last)
            t._out.remove(s)
          for t in s._out:
            if t != last:
              last.exit(t)
              t.enter(last)
            t._in.remove(s)
          for t in s.o_in:
            if t != last:
              last.enter(t, jump=True)
              t.exit(last, jump=True)
            t.o_out.remove(s)
          for t in s.o_out:
            if t != last:
              last.exit(t, jump=True)
              t.enter(last, jump=True)
            t.o_in.remove(s)
          last.type = 'stop'
          parent.job.stop = last
          Task.all.pop(s.id)
        return None
    elif flow[i] == ']':
      if inner:
        if last is not None:
          if parent.type == 'while' or parent.type == 'loop':
            parent.enter(last)
            last.exit(parent)
        return i
      else:
        raise FormatError()
    elif flow[i] == 'W':
      t = Task()
      t.type = 'while'
      t.job = parent.job
      t.setPosition(parent.job.maxpos+1)
      t.setLevel(level)
      if last is None:
        last = parent
      last.exit(t)
      t.enter(last)
      last = t
      i = parseFlow(flow, i+1, level+1, last)
    elif flow[i] == 'L':
      t = Task()
      t.type = 'loop'
      t.job = parent.job
      t.setPosition(parent.job.maxpos+1)
      t.setLevel(level)
      if last is None:
        last = parent
      last.exit(t)
      t.enter(last)
      last = t
      i = parseFlow(flow, i+1, level+1, last)
    elif flow[i] == 'I':
      t = Task()
      t.type = 'if'
      t.job = parent.job
      t.setPosition(parent.job.maxpos+1)
      t.setLevel(level)
      if last is None:
        last = parent
      last.exit(t)
      t.enter(last)
      last = t
      i = parseFlow(flow, i+1, level+1, last)
      t1 = current
      t2 = Task.all[int(flow[i+1])]
      t1.exit(t2)
      t2.enter(t1)
    elif flow[i] == 'F':
      fun = Function.all[int(flow[i+2])]
      i = i + 3
      t = Task(name=fun.name)
      t.type = 'call'
      t.job = parent.job
      t.setPosition(parent.job.maxpos+1)
      t.setLevel(level)
      if last is None:
        last = parent
      last.exit(t)
      t.enter(last)
      last = t
    elif flow[i] == 'C':
      if inner:
        if last is None:
          last = parent
        t = Task.all[int(flow[i+2])]
        w = None
        for w in Task.all.values():
          if w.type == 'while' or w.type == 'loop':
            if t in w._out:
              break
        if w is not None:
          last.exit(w, jump=True)
          w.enter(last, jump=True)
        i = i + 3
      else:
        raise FormatError()
    elif flow[i] == 'B':
      if inner:
        if last is None:
          last = parent
        t = Task.all[int(flow[i+2])]
        last.exit(t, jump=True)
        t.enter(last, jump=True)
        i = i + 3
      else:
        raise FormatError()
    elif flow[i] == 'R':
      t = parent.job.stop
      last.exit(t, jump=True)
      t.enter(last, jump=True)
    elif flow[i] == 'S!':
      last.type = 'shutdown'
    else:
      try:
        t = Task.all[int(flow[i])]
      except:
        continue
      t.job = parent.job
      t.setPosition(parent.job.maxpos+1)
      t.setLevel(level)
      if last is None:
        last = parent
      if not (last.level == t.level and last.type == 'loop'):
        last.exit(t)
        t.enter(last)
      last = t
    i = i+1

profile = args.file
if not profile.endswith(".profile"):
  profile = profile+".profile"
f = open(profile, "r")

line = readLine(f)
jobn = int(line)
for j in range(jobn):
  line = readLine(f)
  name, id = line.split("\t")
  job = Job(name, int(id))
  #~ job.position = jobn-int(j)-1
line = readLine(f)
funn = int(line)

for i in range(funn):
  line = readLine(f)
  name, id = line.split("\t")
  fun = Function(name, int(id))
  #~ fun.position = funn-int(i)-1

line = readLine(f)
taskn = int(line)
for t in range(taskn):
  line = readLine(f)
  name, id = line.split("\t")
  task = Task(name, int(id))

for j in range(jobn):
  line = readLine(f)
  job, flow = line.split("\t")
  job = Job.all[int(job)]
  job.stop = Task()
  job.stop.type = 'stop'
  job.stop.job = job
  flow = flow.split(" ")
  current = Task.all[int(flow[0])]
  current.position = 0
  current.level = 0
  current.job = job
  job.first = current
  parseFlow(flow, 1, 0, current)

for i in range(funn):
  line = readLine(f)
  fun, flow = line.split("\t")
  fun = Function.all[int(fun)]
  fun.stop = Task()
  fun.stop.type = 'stop'
  fun.stop.job = fun
  flow = flow.split(" ")
  current = Task.all[int(flow[0])]
  current.position = 0
  current.level = 0
  current.job = fun
  fun.first = current
  parseFlow(flow, 1, 0, current)

line = readLine(f)
line = readLine(f)
i = 0
while line != '':
  line = line.replace('\n', '')
  job, task, start, end = line.split('\t')
  Task.all[int(task)].order.append(i)
  i = i+1
  line = readLine(f)

f.close()

maxlev = 0
maxpos = 0
for j in Job.all.values():
  maxlev = j.maxlev if j.maxlev > maxlev else maxlev
  maxpos = j.maxpos if j.maxpos > maxpos else maxpos
maxlev = maxlev + 1
maxpos = maxpos + 1

#~ print("\033c")
#~ for j in Job.all.values():
  #~ print("\033[;{}f{}".format(j.position*maxlev*4+1, j.name))
  #~ pass

#~ for t in Task.all.values():
  #~ print("\033[{};{}f".format(t.position+3, (t.job.position*maxlev+t.level)*4+1), end="")
  #~ if t.type == 'task':
    #~ print(t.id)
  #~ elif t.type == 'while':
    #~ print("W")
  #~ elif t.type == 'if':
    #~ print('I')
#~ print("\033[{}f".format(maxpos+2))

job_format = r"\node [scale=\schemoScale, draw, line width=\schemoThick] (j{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\textbf{{{job.name}}}}}}};"+"\n"
fun_format = r"\node [scale=\schemoScale, draw, line width=\schemoLine] (j{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\textit{{{job.name}}}}}}};"+"\n"
task_format = r"\node [scale=\schemoScale, draw, circle, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{%s}}}};" % ("{node.id}" if showid else "")+"\n"
while_format = r"\node [scale=\schemoScale, draw, diamond, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\texttt{{while}}}}}};"+"\n"
loop_format = r"\node [scale=\schemoScale, draw, diamond, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\texttt{{loop}}}}}};"+"\n"
if_format = r"\node [scale=\schemoScale, draw, diamond, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\texttt{{if}}}}}};"+"\n"
call_format = r"\node [scale=\schemoScale, draw, rectangle, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\begin{{varwidth}}{{\schemoWidth}}\texttt{{call}} \textit{{{node.name}}}\end{{varwidth}}}}}};"+"\n"
stop_format = (
  r"\node [scale=\schemoScale, draw, circle, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{}}}};"+"\n"+
  r"\node [scale=\schemoScale, draw, cross out, line width=\schemoLine] at (t{id}) {{\rotatebox{{\schemoRotation}}{{}}}};"+"\n"+
  r"\node [scale=\schemoScale, above] at (t{id}.north) {{\rotatebox{{\schemoRotation}}{{STOP}}}};"+"\n"
)
return_format = (
  r"\node [scale=\schemoScale, draw, circle, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{}}}};"+"\n"+
  r"\node [scale=\schemoScale, draw, cross out, line width=\schemoLine] at (t{id}) {{\rotatebox{{\schemoRotation}}{{}}}};"+"\n"+
  r"\node [scale=\schemoScale, above] at (t{id}.north) {{\rotatebox{{\schemoRotation}}{{RETURN}}}};"+"\n"
)
shutdown_format = r"\node [scale=\schemoScale, draw, star, star points=10, line width=\schemoLine] (t{id}) at ({x},{y}) {{\rotatebox{{\schemoRotation}}{{\textbf{{!}}}}}};"+"\n"

edge_format = r"\draw [-{{Latex[scale=\schemoScale]}}, line width=\schemoThick] (t{src}{anchor1}) to [out={outangle}, in={inangle}]{additional} (t{dst}{anchor2});"+"\n"
jump_format = r"\draw [dashed, -{{Latex[scale=\schemoScale]}}, line width=\schemoLine] (t{src}{anchor1}) to [out={outangle}, in={inangle}]{additional} (t{dst}{anchor2});"+"\n"

order_format = r"\node [scale=\schemoSmall, above right] at (t{task}.north east) {{\rotatebox{{\schemoRotation}}{{{order}}}}};"+"\n"

def addNode(t, graph):
  if t.type == 'task':
    node_format = task_format
  elif t.type == 'while':
    node_format = while_format
  elif t.type == 'loop':
    node_format = loop_format
  elif t.type == 'if':
    node_format = if_format
  elif t.type == 'call':
    node_format = call_format
  elif t.type == 'stop':
    if isinstance(j, Job):
      node_format = stop_format
    elif isinstance(j, Function):
      node_format = return_format
  elif t.type == 'shutdown':
    node_format = shutdown_format
  graph = graph + node_format.format(
    id=t.id,
    x=2*(t.position+1),
    y=t.level,
    #~ name=t.id,
    node=t
  )
  if len(t.order)>3:
    order = "{}, {} ... {}".format(t.order[0], t.order[1], t.order[-1])
  else:
    order = ", ".join(map(str, t.order))
  graph = graph + order_format.format(
    task=t.id,
    order=order
  )
  return graph

def addEdges(t, graph):
  for t2 in t.o_out:
    anchor1 = ""
    anchor2 = ""
    additional = ""
    if t2.position > t.position:
      if t2.type == 'stop':
        outangle = -90
        inangle = -135
        text = ''
        if isinstance(j, Job):
          text = 'exit'
        elif isinstance(j, Function):
          if j.stop in t._out:
            continue
          text = 'return'
        additional = r" node [scale=\schemoSmall, at start, below right] {\rotatebox{\schemoRotation}{%s}}" % text
      else:
        outangle = -90
        inangle = 180
        additional = r" node [scale=\schemoSmall, at start, below right] {\rotatebox{\schemoRotation}{break}}"
    else:
      outangle = 90
      inangle = 90
      additional = r" node [scale=\schemoSmall, at start, above left] {\rotatebox{\schemoRotation}{continue}}"
    graph = graph + jump_format.format(
      src=t.id,
      anchor1=anchor1,
      dst=t2.id,
      anchor2=anchor2,
      outangle=outangle,
      inangle=inangle,
      additional=additional
    )
  for t2 in t._out:
    outangle = 0
    inangle = 180
    anchor1 = ""
    anchor2 = ""
    additional = ""
    if t2.level < t.level:
      if t2.type == 'while' or t2.type == 'loop':
        outangle = 90
        inangle = 90
        anchor2 = ".north"
      else:
        outangle = 0
        inangle = 135
    if t.type == 'if':
      if t2.level > t.level:
        outangle = 90
        inangle = 180
        anchor1 = ".north"
        additional = r" node [scale=%f, at start, above left] {\rotatebox{%s}{true}}" % (scale*2/3, rotation)
      else:
        outangle = -90
        inangle = -135
        anchor1 = ".south"
        additional = r" node [scale=%f, at start, below left] {\rotatebox{%s}{false}}" % (scale*2/3, rotation)
    elif t.type == 'while':
      if t2.level > t.level:
        outangle = 0
        inangle = -90
        anchor1 = ".east"
        additional = r" node [scale=%f, at start, below right] {\rotatebox{%s}{true}}" % (scale*2/3, rotation)
      else:
        outangle = -90
        inangle = -135
        anchor1 = ".south"
        additional = r" node [scale=%f, at start, below left] {\rotatebox{%s}{false}}" % (scale*2/3, rotation)
    elif t.type == 'loop':
      if t2.level > t.level:
        outangle = 0
        inangle = -90
        anchor1 = ".east"
      else:
        continue
    graph = graph + edge_format.format(
      src=t.id,
      anchor1=anchor1,
      dst=t2.id,
      anchor2=anchor2,
      outangle=outangle,
      inangle=inangle,
      additional=additional,
      scale=scale
    )
  return graph

graphs = []
l = []
if showfun:
  l = l + list(Function.all.values())
if showjob:
  l = l + list(Job.all.values())
for j in (l):
  graph = r"\adjustbox{valign=t}{\begin{tikzpicture}[x=\schemoUnit, y=\schemoUnit, transform shape, rotate=-\schemoRotation]"+"\n"
  if isinstance(j, Job):
    node_format = job_format
  elif isinstance(j, Function):
    node_format = fun_format
  graph = graph + node_format.format(
    id=j.id,
    x=0,
    y=0,
    job=j,
    scale=scale,
    rotation=rotation
  )
  
  tasks = []
  if unaccessible:
    for t in Task.all.values():
      if t.job != j:
        continue
      tasks.append(t)
  else:
    ts = [j.first]
    while len(ts) > 0:
      t = ts.pop(0)
      if t.visited:
        continue
      t.visited = True
      tasks.append(t)
      for t2 in t._out:
        ts.append(t2)
      for t2 in t.o_out:
        ts.append(t2)
  
  for t in tasks:
    graph = addNode(t, graph)
  for t in tasks:
    graph = addEdges(t, graph)
  
  graph = graph + r"\end{tikzpicture}}"
  graphs.append(graph)

graph = ((r'\\' if vertical else '&') + "\n").join(graphs)

f = open("profile.template", "r")
template = f.read()
f.close()

if vertical:
  tab_format = '{l}'
else:
  tab_format = '{'+':'.join(['c']*(len(Job.all)+len(Function.all)))+'}'

f = open(profile.replace(".profile", ".tex"), "w")
f.write(
  template % (
    scale,
    rotation,
    str(scale_*10)+"mm",
    "15mm",
    scale*2/3,
    str(scale*0.4)+"pt",
    str(scale*0.8)+"pt",
    tab_format,
    graph.replace("_", r"\_")
  )
)
f.close()
